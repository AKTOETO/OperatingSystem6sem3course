#include "taskmanager.h"

void killAllBGTaskSignal(int sig)
{
    killFGTask();
    killAllBGTask();
}

// является тип задачи bg
bool isItBackground(size_t* argc, char **argv)
{
    // проверяем на наличие токенов
    if(argc <= 0 || argv == NULL)
        ERRORS("Недостаточно токенов");

    // берем последний токен
    // если он &, удаляем его (NULL а его место), возвращаем true
    if(argv[(*argc) - 1][0] == '&')
    {
        argv[--(*argc)] = NULL;
        return true;
    }

    // иначе возвращаем false
    return false;
}

int main(int argc, char** args)
{
    char *str = NULL;
    char **argv = NULL;
    size_t argnum = 0;

    // // установка сигнала уничтожения всех bg задач на ctrl c
    // signal(SIGINT, killAllBGTaskSignal);

    // // если есть флаг -i, то выключаем информационные сообщения
    // if(argc > 1 && strcmp(args[1], "-i") == 0)
    // {
    //     INFOS("Информационные сообщения выключены\n");
    //     g_use_info = 0;
    // }
    
    while(true)
    {
        // печать приглашения
        printHi();

        // считывание строки
        str = readLine();
        if(str == NULL)
        {
            ERRORS("Строка не была создана\n");
            return 1;
        }
        INFO("%s\n", str);

        // получение токенов
        argv = tokenizeString(str, &argnum);

        if(argv == NULL)
        {
            ERRORS("Массив токенов не существует\n");
            free(str);
            return 1;
        }

        // печать токенов
        if(g_use_info)
            printTokens(argv);

        // индекс задачи из подготовленного списка возможных задач
        int ind = 0;

        // проверяем на наличие символа &, если есть, то процесс bg
        if(isItBackground(&argnum, argv))
        {
            // добавление bg процесса
            {
                // получаю pid нового процесса
                pid_t pid = fork();

                // проверяю три возможные ситуации
                // 1) поток не был создан
                if(pid < 0)
                {
                    ERRORS("Поток не был создан\n");
                }
                // 2) сейчас выполняется дочерний процесс
                if(pid == 0)
                {
                    // можно вынести в указательна функцию и передават ее при вызове
                    // это нужно для создания одной функции для вызова создания bg и fg процессов
                    {
                        // попытка запустить нужную программу
                        // проверка: задача для bg из массива или нет
                        if((ind = isItFromBgTaskList(argv[0])) != -1)
                        {   
                            INFO("Запускаем задачу g_bg_task_func[%d]\n", ind);

                            // запускаем соответствующую функцию
                            g_bg_task_func[ind](argnum, argv);
                        }

                        // если задача не из массива - запускаем execvp
                        // проверяем, запустился ли код 
                        else if(execvp(argv[0], argv) == -1)
                        {
                            // код не был запущен
                            ERRORS("Execvp не смогла запустить код\n");
                        }
                        // если же код не -1, тогда процесс успешно запущен
                        else
                        {
                            INFO("Процесс [%s] успешно запущен\n", argv[0]);
                        }

                    }
                        
                    // выход из дочернего процесса
                    exit(0);
                }
                // 3) сейчас выполняется родительский процесс
                else
                {
                    printTokens(argv);

                    // сохранение bg процесса в массив
                    addBackgroundTask(pid, argnum, argv);
                }
            }
        }

        // если нет & проверяем команду на вхождение в список команд, 
        // исполняемых в main процессе, если есть совпадение - выполняем в мейне
        else if((ind = isItFromMainTaskList(argv[0])) != -1)
        {
            // выполняем команду под индексом ind из массива команд g_main_task_func
            // если вернулось -1 => была вызвана функция out => надо завершить программу
            if(g_main_task_func[ind](argnum, argv) == -1)
            {
                break;
            }
        }

        // если все предыдущее ложно - процесс fg.
        else
        {
            // добавление fg процесса
            {
                // получаю pid нового процесса
                pid_t pid = fork();

                // проверяю три возможные ситуации
                // 1) поток не был создан
                if(pid < 0)
                {
                    ERRORS("Поток не был создан\n");
                }
                // 2) сейчас выполняется дочерний процесс
                if(pid == 0)
                {
                    // можно вынести в указательна функцию и передават ее при вызове
                    // это нужно для создания одной функции для вызова создания bg и fg процессов
                    {
                        // попытка запустить нужную программу
                        // проверка: задача для bg из массива или нет
                        if((ind = isItFromFgTaskList(argv[0])) != -1)
                        {   
                            INFO("Запускаем задачу g_fg_task_func[%d]\n", ind);

                            // запускаем соответствующую функцию
                            g_fg_task_func[ind](argnum, argv);
                        }

                        // если задача не из массива - запускаем execvp
                        // проверяем, запустился ли код 
                        else if(execvp(argv[0], argv) == -1)
                        {
                            // код не был запущен
                            ERRORS("Execvp не смогла запустить код\n");
                        }
                        // если же код не -1, тогда процесс успешно запущен
                        else
                        {
                            INFO("Процесс [%s] успешно запущен\n", argv[0]);
                        }
                    }
                        
                    // выход из дочернего процесса
                    exit(0);
                }
                // 3) сейчас выполняется родительский процесс
                else
                {
                    // сохранение fg процесса в массив
                    addForegroundTask(pid, argnum, argv);

                    // ожидание завершения fg процесса
                    waitFGTask();
                }
            }
        }


        // // запуск процессов
        // if(argvProcessing(argv, argnum) == -1)
        // {
        //     INFOS("Конец работы оболочки\n");
        //     break;
        // }

        // освобождение памяти
        free(str); 
        free(argv);
    }
    quit();
    if(str) free(str);
    if(argv) free(argv);
    return 0;
}
